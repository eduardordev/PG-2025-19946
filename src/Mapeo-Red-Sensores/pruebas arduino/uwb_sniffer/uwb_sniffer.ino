// Definiciones de pines ANTES de incluir dw3000_*.h
#define DW3000_CS_PIN   4   // ← Cambiado a 4 como en el ejemplo que funciona
#define DW3000_RST_PIN  27
#define DW3000_IRQ_PIN  34

#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <U8g2lib.h>

#include <dw3000.h>
#include <dw3000_port.h>
#include <dw3000_regs.h>
#include <dw3000_device_api.h>

// Pines para placa ESP32 UWB v1.0 de Makerfabs
// Configuración oficial del datasheet (más estable)
static const int PIN_SS   = 4;    // CS (GPIO4) - Como en el ejemplo que funciona
static const int PIN_RST  = 27;  // RST (GPIO27)
static const int PIN_IRQ  = 34;  // IRQ (GPIO34 input-only)
static const int PIN_SCK  = 18;  // SCK (GPIO18 → VSPICLK)
static const int PIN_MISO = 19;  // MISO (GPIO19 → VSPIQ)
static const int PIN_MOSI = 23;  // MOSI (GPIO23 → VSPID)

// OLED Display
U8G2_SH1106_128X64_NONAME_F_SW_I2C oled(U8G2_R0, /* clock=*/9, /* data=*/8, /* reset=*/U8X8_PIN_NONE);

// Simple Sniffer Configuration - Using only basic functions
#define MAX_PACKET_LEN 1024
#define SNIFFER_CHANNEL 5  // Channel 5 (6.5 GHz) - canal recomendado para Estimote

// Global variables for sniffer
static uint8_t rxBuffer[MAX_PACKET_LEN];
static uint16_t frameLen = 0;
static uint32_t packetCount = 0;
static uint32_t lastPacketTime = 0;

// Logo UVG (64x64 px aprox)
const unsigned char uvg_logo [] PROGMEM = {
  0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x38, 0x00, 0x9c, 0x07, 0x80, 0x07, 0xfc, 0x03, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0xfe, 0x07, 0xc0, 0x07, 0xff, 0x0f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x9e, 0x0f, 0xc0, 0xc7, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x9e, 0x0f, 0xc0, 0xe3, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x0f, 0xe0, 0xf3, 0x0f, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x1f, 0xe0, 0xf3, 0x03, 0x08, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x1f, 0xe0, 0xf9, 0x01, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x1e, 0xf0, 0xf9, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x3e, 0xf0, 0x7c, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x3e, 0xf0, 0x7c, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x3c, 0xf8, 0x7c, 0xc0, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x7c, 0xf8, 0x7c, 0xc0, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x7c, 0x7c, 0x7c, 0xc0, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0x78, 0x7c, 0x7c, 0xc0, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0xf8, 0x3c, 0x7c, 0x00, 0x1e, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1e, 0xf0, 0x3c, 0x7c, 0x00, 0x1e, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x7c, 0x00, 0x1f, 0xf0, 0x1f, 0xf8, 0x00, 0x1e, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0xf8, 0x00, 0x1f, 0xf0, 0x1f, 0xf8, 0x01, 0x1e, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0xf8, 0x81, 0x1f, 0xe0, 0x1f, 0xf0, 0x03, 0x1e, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0xf0, 0xff, 0x0f, 0xe0, 0x1f, 0xf0, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0xf0, 0xff, 0x07, 0xe0, 0x0f, 0xe0, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0xe0, 0xff, 0x07, 0xc0, 0x0f, 0xc0, 0xff, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x80, 0xff, 0x01, 0xc0, 0x07, 0x00, 0xff, 0x07, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x02, 0x00, 0xcf, 0x71, 0x78, 0x00, 0x0f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x84, 0x46, 0x45, 0x01, 0x08, 0x8a, 0x18, 0x11, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x84, 0x4a, 0x45, 0x01, 0x18, 0x0a, 0x01, 0x21, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x84, 0x62, 0x29, 0x4f, 0x21, 0x0a, 0x25, 0x21, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x84, 0x62, 0x29, 0x01, 0x81, 0x0a, 0x3d, 0x21, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x22, 0x11, 0x01, 0x80, 0x8a, 0xc0, 0x11, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x78, 0x20, 0x00, 0x00, 0x78, 0x68, 0x00, 0x0d, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x8c, 0x18, 0x04, 0x08, 0x60, 0x08, 0x00, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x09, 0x04, 0x10, 0x62, 0x08, 0x00, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x0a, 0x04, 0x10, 0x80, 0x08, 0x00, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0xfa, 0x04, 0x10, 0x91, 0x08, 0x00, 0x1f, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x1a, 0x04, 0x00, 0x91, 0x08, 0x00, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x0a, 0x04, 0xa0, 0x98, 0x09, 0x00, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x09, 0x04, 0xc0, 0x08, 0x09, 0x00, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0xcc, 0x18, 0x04, 0x40, 0x04, 0x0a, 0x04, 0x01, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x3c, 0x0f, 0x07, 0xd0, 0x77, 0x21, 0x02, 0x08, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x44, 0x00, 0x00, 0x18, 0x11, 0x23, 0x02, 0x08, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x01, 0x00, 0x08, 0x11, 0x23, 0x01, 0x10, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x04, 0x40, 0x00, 0x3c, 0x11, 0x13, 0x07, 0x1c, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x44, 0x80, 0x00, 0x05, 0x01, 0x8d, 0x08, 0x02, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x24, 0x00, 0x24, 0x01, 0x10, 0x09, 0x08, 0x02, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 
	0xff, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff
};

const unsigned char jack [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x07, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xe3, 0xf9, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x71, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x19, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0x0c, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xf2, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf3, 0x7f, 0x17, 0xfe, 0x0f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xf3, 0x7f, 0x02, 0xfc, 0x07, 0xd8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe1, 0xbf, 0x01, 0x00, 0x03, 0xc0, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xd1, 0x3f, 0x00, 0xf0, 0x01, 0xc8, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x31, 0x3f, 0x00, 0xe0, 0xf3, 0xcf, 0xf7, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x73, 0x00, 0x00, 0xc0, 0x79, 0xc7, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xe3, 0xbf, 0x3f, 0x00, 0x00, 0xc0, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc3, 0x7f, 0x02, 0x00, 0x70, 0xe0, 0xf3, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xbf, 0x83, 0x3f, 0xe0, 0x0f, 0x7c, 0x00, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x7f, 0x06, 0x00, 0xf8, 0xdf, 0x64, 0x60, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x0c, 0x00, 0xf0, 0xdc, 0x2c, 0x20, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x11, 0x00, 0xf0, 0xdc, 0x3c, 0x90, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x23, 0x0e, 0xe0, 0xdf, 0x01, 0x88, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xd3, 0x39, 0xc0, 0xc1, 0x03, 0x8c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x63, 0xe0, 0x00, 0xc0, 0x07, 0xc6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xc3, 0x9f, 0x03, 0xa8, 0xef, 0xe3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x87, 0x3f, 0x0f, 0x00, 0x07, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x07, 0x3f, 0x3c, 0x00, 0x87, 0xc1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x0f, 0x1c, 0xf0, 0x00, 0x80, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xc0, 0x03, 0x00, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x80, 0x03, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x0f, 0x1e, 0x00, 0x40, 0x20, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x1f, 0xff, 0x00, 0x50, 0x20, 0x00, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x48, 0x00, 0xc0, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x3c, 0x00, 0x00, 0x00, 0xfb, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x1e, 0x00, 0x00, 0x00, 0x02, 0xfe, 0xfe, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xfd, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x7c, 0x00, 0x00, 0xf8, 0x03, 0x00, 0xc0, 0xf9, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x3f, 0xff, 0x8f, 0x01, 0xbc, 0x0b, 0x00, 0x80, 0xfb, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x9f, 0xff, 0x1f, 0x01, 0x70, 0x0f, 0x00, 0x00, 0xf7, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xcf, 0xdf, 0x03, 0x19, 0x50, 0x0f, 0xc0, 0x01, 0xf6, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xef, 0x03, 0x00, 0x08, 0x60, 0x00, 0xe0, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xf3, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x07, 0x00, 0xfc, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x39, 0x00, 0x00, 0x00, 0x80, 0x00, 0xfc, 0x07, 0x80, 0xf9, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x1f, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x03, 0x00, 0xfb, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xc7, 0x03, 0xf0, 0x00, 0x0c, 0x03, 0x00, 0xff, 0x1b, 0x00, 0xf6, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xf7, 0x00, 0xf8, 0x03, 0x0c, 0x07, 0x80, 0xff, 0x09, 0xd8, 0xf4, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x33, 0x0c, 0xf8, 0x0f, 0x8c, 0x3f, 0x9e, 0xff, 0xcd, 0x99, 0xf4, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x03, 0x07, 0xc0, 0x1f, 0x0c, 0xe0, 0x9f, 0xff, 0xc3, 0x99, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x83, 0x03, 0x98, 0x7f, 0x9c, 0xff, 0x9f, 0xff, 0xdb, 0xd9, 0xf0, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x83, 0x01, 0xb0, 0xff, 0x9c, 0xff, 0x9f, 0xff, 0xd3, 0xcc, 0xfc, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x8b, 0x00, 0xa0, 0xff, 0x1d, 0xff, 0xbf, 0xff, 0x47, 0x47, 0xfd, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x93, 0x88, 0x83, 0xff, 0x1d, 0xff, 0xbf, 0xff, 0x3f, 0x30, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x17, 0x98, 0xc3, 0xff, 0x1d, 0xff, 0x3f, 0xff, 0xff, 0xb3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x0f, 0x98, 0xdb, 0xff, 0x3d, 0xff, 0x77, 0xff, 0xff, 0xe3, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0x5f, 0x13, 0xe2, 0xff, 0x3b, 0xfe, 0x7c, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x82, 0xf8, 0xff, 0x3b, 0x1c, 0x7f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0x19, 0xfe, 0xff, 0x3b, 0xfe, 0xff, 0xfe, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x73, 0xfc, 0xff, 0x3c, 0x30, 0xfc, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0xf8, 0xff, 0x8c, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xff
};

// Function prototypes - Using only basic functions
static void wait_ms(uint32_t ms) { delay(ms); }
void showWelcomeMessage();
void displayPacketInfo(uint8_t* data, uint16_t len);
void setupSnifferMode();
void processReceivedPacket();
void printPacketInfo(uint8_t* data, uint16_t len);
void printHexDump(uint8_t* data, uint16_t len);
bool isEstimotePacket(uint8_t* data, uint16_t len);
void testSnifferFunctionality();
void toggleDebugMode();

void showWelcomeMessage() {
  oled.clearBuffer();
  oled.drawXBMP(0, 0, 128, 64, uvg_logo);  // Mostrar logo UVG
  oled.sendBuffer();
  delay(2000);

  oled.clearBuffer();
  oled.drawXBMP(0, 0, 128, 64, jack);  // Mostrar logo Jack
  oled.sendBuffer();
  delay(2000);

  oled.clearBuffer();
  oled.setFont(u8g2_font_6x10_tr);
  oled.drawStr(0, 20, "Bienvenido al Sniffer");
  oled.drawStr(0, 35, "AR UVG TOUR");
  oled.drawStr(0, 50, "UWB Packet Listener");
  oled.sendBuffer();
  delay(2500);
}

void displayPacketInfo(uint8_t* data, uint16_t len) {
  oled.clearBuffer();
  oled.setFont(u8g2_font_5x7_tr);
  oled.drawStr(0, 10, "Paquete UWB capturado");
  
  char packetInfo[32];
  sprintf(packetInfo, "Tam: %d bytes", len);
  oled.drawStr(0, 25, packetInfo);
  
  oled.drawStr(0, 40, "Bytes:");
  
  for (int i = 0; i < min((int)len, 8); i++) {
    char hexChar[4];
    sprintf(hexChar, "%02X", data[i]);
    oled.drawStr(5 + (i * 14), 55, hexChar);
  }
  
  oled.sendBuffer();
}

void setup() {
  // Start serial communication
  Serial.begin(115200);
  
  // Wait for serial to initialize
  while (!Serial) {
    delay(10);
  }
  
  // Add extra delay to ensure serial is ready
  delay(1000);

  // Initialize OLED display
  Wire.begin(8, 9);
  oled.begin();
  oled.setFont(u8g2_font_6x10_tr);

  // Show welcome message
  showWelcomeMessage();

  // 0) Asegurar CS alto antes de tocar SPI
  pinMode(PIN_SS, OUTPUT);
  digitalWrite(PIN_SS, HIGH);

  // 1) Configurar IRQ como entrada (sin pull-up - GPIO34 es input-only)
  pinMode(PIN_IRQ, INPUT);

  // 2) SPI usando las funciones del ejemplo que funciona
  spiBegin(PIN_IRQ, PIN_RST);  // ← Función del ejemplo que funciona
  spiSelect(PIN_SS);           // ← Función del ejemplo que funciona
  delay(2);                    // ← Delay del ejemplo que funciona

  // 3) Verificar que DW3000 esté en IDLE antes de continuar (como en el ejemplo)
  while (!dwt_checkidlerc()) {
    delay(100);
  }

  // 3) (Opcional) Si el port tiene helpers para reset/probe, úsalos:
#if defined(reset_DWIC)
  reset_DWIC();
  wait_ms(2);
#endif

#if defined(dwt_probe)
  int pr = dwt_probe();
#endif

  // 5) Probe de Device ID con reintentos y diagnósticos
  uint32_t devId = 0;
  
  for (int i = 0; i < 10; i++) {
    // Asegurar CS alto antes de cada lectura
    digitalWrite(PIN_SS, HIGH);
    delay(1);
    digitalWrite(PIN_SS, LOW);
    delay(1);
    
    devId = dwt_readdevid();
    
    if (devId != 0 && devId != 0xFFFFFFFF) {
      break;
    }
    
    // Restaurar CS alto
    digitalWrite(PIN_SS, HIGH);
    delay(500);
  }

  // 4) Inicializar driver (como en el ejemplo que funciona)
  if (dwt_initialise(DWT_DW_INIT) == DWT_ERROR) {
    while (1) { delay(1000); }
  }
  
  // 4.5) Fijar XTRIM manualmente para evitar fallo OTP
  dwt_setxtaltrim(0x20);  // 0x1F-0x22 suele ser razonable

  // 6) Cambiar a SPI rápido tras init
#if defined(port_set_dw_ic_spi_fastrate)
  port_set_dw_ic_spi_fastrate();
#else
  SPI.setFrequency(8000000); // 8 MHz si no hay función específica
#endif

  // 7) Configurar UWB con parámetros específicos
  
  // SPI lento durante configuración (si hay problemas de PLL)
  SPI.setFrequency(4000000); // 4 MHz para configuración estable

  uint8_t code = (SNIFFER_CHANNEL == 5) ? 10 : 9;
  // Configuración UWB completa (nombres corregidos para tu librería)
  dwt_config_t cfg = {
    .chan           = SNIFFER_CHANNEL, // usa la constante que imprimes
    .txPreambLength = DWT_PLEN_128,  // Estimote suele usar 128 símbolos
    .rxPAC          = DWT_PAC8,
    .txCode         = code,
    .rxCode         = code,
    .dataRate       = DWT_BR_6M8,
    .phrMode        = DWT_PHRMODE_STD,
    .sfdTO          = 129             // preámbulo + 1
  };
  
  if (dwt_configure(&cfg) == DWT_ERROR) {
    while (1) { delay(1000); }
  }
  
  // Restaurar SPI rápido para sniffing
  SPI.setFrequency(8000000); // 8 MHz para sniffing
  
  // 8) Setup modo sniffer (sin filtros MAC)
  setupSnifferMode();

  // Display ready message
  oled.clearBuffer();
  oled.setFont(u8g2_font_6x10_tr);
  oled.drawStr(0, 20, "Sniffer UWB Activo");
  oled.drawStr(0, 40, "Esperando paquetes...");
  oled.sendBuffer();
}

void loop() {
  // Check for received packets
  processReceivedPacket();
  
  // Handle serial commands for debugging (removed for OLED display)
  
  // Status display every 10 seconds
  static uint32_t t0 = millis();
  if (millis() - t0 >= 10000) {
    oled.clearBuffer();
    oled.setFont(u8g2_font_6x10_tr);
    oled.drawStr(0, 15, "Sniffer UWB Activo");
    
    char statusText[32];
    sprintf(statusText, "Paquetes: %d", packetCount);
    oled.drawStr(0, 35, statusText);
    
    sprintf(statusText, "Uptime: %ds", millis() / 1000);
    oled.drawStr(0, 55, statusText);
    
    oled.sendBuffer();
    t0 = millis();
  }
  
  // Small delay to prevent overwhelming the system
  delay(1);
}

// Sniffer setup con configuración completa
void setupSnifferMode() {
  // Deshabilitar filtros MAC para capturar todos los paquetes
  dwt_configureframefilter(0,0);  // sin filtros MAC
  
  // Configurar escucha continua (sin timeout)
  dwt_setrxtimeout(0);  // 0 = escucha continua
  
  // Limpiar flags de RX y activar
  dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_ALL_RX_ERR | SYS_STATUS_ALL_RX_TO | SYS_STATUS_RXFCG_BIT_MASK);
  
  // Activar recepción inmediata
  dwt_rxenable(DWT_START_RX_IMMEDIATE);
}

// Procesamiento de paquetes usando status bits (método correcto)
void processReceivedPacket() {
  static uint32_t lastCheck = 0;
  static bool debugMode = true;
  
  if (millis() - lastCheck > 50) { // Check every 50ms para mejor responsividad
    
    // Leer status register
    uint32_t status = dwt_read32bitreg(SYS_STATUS_ID);
    
    // Verificar si hay un frame bueno (Frame good)
    if (status & SYS_STATUS_RXFCG_BIT_MASK) {  // ← Corregido: SYS_STATUS_RXFCG_BIT_MASK
      // Frame good - procesar paquete
      uint32_t finfo = dwt_read32bitreg(RX_FINFO_ID);
      uint16_t frameLen = (finfo & RX_FINFO_STD_RXFLEN_MASK) >> RX_FINFO_RXFLEN_BIT_LEN;
      
      if (frameLen > MAX_PACKET_LEN) {
        frameLen = MAX_PACKET_LEN;
      }
      
      // Leer datos del paquete
      dwt_readrxdata(rxBuffer, frameLen, 0);
      
      // Limpiar flags (incluyendo errores y timeouts)
      dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_RXFCG_BIT_MASK | SYS_STATUS_ALL_RX_ERR | SYS_STATUS_ALL_RX_TO);
      
      // Procesar paquete
      packetCount++;
      lastPacketTime = millis();
      
      // Display packet information on OLED
      displayPacketInfo(rxBuffer, frameLen);
      
      // Limpiar buffer
      memset(rxBuffer, 0, MAX_PACKET_LEN);
      
      // Reactivar RX
      dwt_rxenable(DWT_START_RX_IMMEDIATE);
      
    } else if (status & (SYS_STATUS_ALL_RX_ERR | SYS_STATUS_ALL_RX_TO)) {
      // Manejar errores y timeouts
      dwt_write32bitreg(SYS_STATUS_ID, SYS_STATUS_ALL_RX_ERR | SYS_STATUS_ALL_RX_TO);
      dwt_rxenable(DWT_START_RX_IMMEDIATE);
    }
    
    lastCheck = millis();
  }
}

// Simple packet information display (OLED only)
void printPacketInfo(uint8_t* data, uint16_t len) {
  // This function is now replaced by displayPacketInfo for OLED display
  // Keeping for compatibility but not used
}

// Print hex dump of packet data (OLED only)
void printHexDump(uint8_t* data, uint16_t len) {
  // This function is now replaced by displayPacketInfo for OLED display
  // Keeping for compatibility but not used
}

// Check if packet might be from Estimote beacon
bool isEstimotePacket(uint8_t* data, uint16_t len) {
  // Estimote UWB beacons typically use specific patterns
  // This is a basic heuristic - you may need to adjust based on actual packets
  
  if (len < 8) return false;
  
  // Check for common Estimote patterns
  // Estimote often uses specific preamble patterns or MAC addresses
  // Look for patterns that might indicate Estimote packets
  
  // Check for Estimote OUI (Organizationally Unique Identifier)
  // Estimote's OUI is typically in the source address field
  if (len >= 8) {
    // Check first 3 bytes of source address for Estimote OUI patterns
    // This is a simplified check - real Estimote packets may vary
    uint32_t oui = (data[2] << 16) | (data[3] << 8) | data[4];
    
    // Some common patterns that might indicate Estimote
    // Note: These are educated guesses and may need adjustment
    if (oui == 0x123456 || oui == 0xABCDEF || oui == 0x000000) {
      return true;
    }
  }
  
  // Check for specific frame types that Estimote might use
  if (len >= 2) {
    uint16_t frameControl = (data[0] << 8) | data[1];
    
    // Look for specific frame control patterns
    // This is a simplified check
    if ((frameControl & 0x0C00) == 0x0800) { // Beacon frame type
      return true;
    }
  }
  
  return false;
}

// Test function to verify sniffer is working properly (OLED only)
void testSnifferFunctionality() {
  // Test functionality removed for OLED display
  // Basic test: Check if DW3000 is responding
  uint32_t devId = dwt_readdevid();
  
  if (devId == 0 || devId == 0xFFFFFFFF) {
    oled.clearBuffer();
    oled.setFont(u8g2_font_6x10_tr);
    oled.drawStr(0, 30, "Error: Device not responding");
    oled.sendBuffer();
    return;
  }
  
  // Test RX enable
  dwt_rxenable(DWT_START_RX_IMMEDIATE);
}

// Toggle debug mode for better debugging (OLED only)
void toggleDebugMode() {
  // Debug mode functionality removed for OLED display
  // Keeping for compatibility but not used
}

// Change UWB channel dynamically (OLED only)
void changeChannel(uint8_t newChannel) {
  uint8_t code = (newChannel == 5) ? 10 : 9;
  
  // Reconfigurar con nuevo canal
  dwt_config_t cfg = {
    .chan           = newChannel,              // cámbialo a 5 si quieres probar canal 5
    .txPreambLength = DWT_PLEN_128,  // Estimote suele usar 128 símbolos
    .rxPAC          = DWT_PAC8,
    .txCode         = code,
    .rxCode         = code,
    .dataRate       = DWT_BR_6M8,
    .phrMode        = DWT_PHRMODE_STD,
    .sfdTO          = 129             // preámbulo + 1
  };
  
  if (dwt_configure(&cfg) == DWT_ERROR) {
    oled.clearBuffer();
    oled.setFont(u8g2_font_6x10_tr);
    oled.drawStr(0, 30, "Error: Channel change failed");
    oled.sendBuffer();
    return;
  }
  
  // Reconfigurar sniffer
  setupSnifferMode();
  
  // Display channel change success
  oled.clearBuffer();
  oled.setFont(u8g2_font_6x10_tr);
  oled.drawStr(0, 30, "Canal cambiado exitosamente");
  oled.sendBuffer();
}